#2110 다시 풀기
n, c = map(int,input().split())
temp = []
for _ in range(n):
  x = int(input())
  temp.append(x)
temp.sort()

mini = 1
maxi = temp[-1] - temp[0]
ans = 0

while (mini <= maxi):
  middle = (maxi + mini) // 2
  curr = temp[0]
  cnt = 1

  for i in range(1,n):
    if temp[i] >= curr + middle:
      cnt += 1
      curr = temp[i]
    
  if cnt >= c:
    mini += middle + 1
    ans = middle
  else:
    maxi = middle - 1

print(ans)

solution:
1. 인접한 두 공유기 사이의 거리를 탐색하는 것이 목표이다.
2. 이때, 시간복잡도를 고려해서 이분탐색을 시도한다.
-> start는 1, end는 (가장 먼 집 - 첫 집)으로 두고 탐색하면 된다.
3. 가장 첫 집에는 공유기를 설치한다고 가정하고 탐색을 진행한다.
4. 각 집 간의 거리차가 middle 이상인 경우에만 공유기를 설치하고 탐색한다.
5. 여타 이진탐색 코드와 다른 점인데, 공유기의 설치 개수를 기준으로 갈래를 나눈다.

추가 설명:
1) https://www.acmicpc.net/board/view/155334 
"어떠한 조건을 만족하도록 하는 어떤 값을 최대화 혹은 최소화하라"는 문제에서 떠올려볼 수 있는 테크닉입니다.

이런 문제를 만났을 때, '최댓값 혹은 최솟값을 직접 구하는 대신, 이 값이 특정 값으로 주어졌다고 쳤을 때 조건을 만족하는 지를 적절한 시간 복잡도 내에 구하는 것이 가능할까?'를 한번 생각해보고, 이것이 가능하다면 조건을 만족하는 값의 경계선을 이분 탐색으로 구하는 것이 가능하다고 생각할 수 있습니다.

이러한 유형의 문제를 파라메트릭 서치, 혹은 매개 변수 탐색이라고 부릅니다. 최적화 문제를 결정 문제로 바꾸는 것인데, 말을 어렵게 썼지만 결국은 위에 쓴 말과 동일한 이야기입니다.

유의할 점이 있는데, 이분 탐색이 정렬된 배열에서 시행되어야 유의미한 결과를 가져오듯이, 최적화 문제 또한 특정 형태를 만족해야 결정 문제로 바꾸어서 해결을 시도해볼 수 있습니다.

바로 각 값에 대해 조건을 만족하는 지의 여부는 전체 범위 중 정확히 한 곳에서만 바뀌어야 한다는 것입니다.

풀어서 쓰면, 각 값에 대해 결정 문제에 대한 진위 여부를 T/F로 쓴다면 이 배열의 형태는 아래와 같아야 합니다.

TTTTT...TTTFFF...FFFFF

혹은

FFFFF..FFFTTT...TTTTT

위와 같은 형태로 결정 문제의 참/거짓 여부가 정해져야만 이분 탐색의 결과가 원하는 경계선에 머물러서 조건을 만족하는 최댓값 (혹은 최솟값)을 구할 수 있게 됩니다.

마지막으로, 최적화 문제를 만났을 때 '결정 문제로 바꾸어서 풀릴까'를 한번 고민해보는 것은 합당한 것이 맞는데, 모든 최적화 문제가 결정 문제로 바꾸어서 풀리는 것은 당연히 아닙니다. 적당히 따져보고 결정 문제로 바꿔서 풀리는 것이 아닐 것 같다고 생각된다면 이 풀이에 너무 얽매이지 않고 다른 풀이를 생각해볼 수 있어야 합니다.



2) 첫 번째 집에 설치하는 이유
https://www.acmicpc.net/board/view/31633
인접한 두 공유기 사이의 최대 거리가 L이다. 라고 가정해 봅시다. 집이 n개 있고요.

그렇다면, n은 상수이지만, L이라는 것은 범위가 변할 수 있단 말이지요.

왜 x축 좌표가 제일 작은, 첫 번째 집부터 설치해 보느냐. 이유는 간단합니다.

x축으로 정렬했을 때, x[1], ... , x[n]인 집들이 있다고 해 봅시다. 단 임의의 i<j에 대해, x[i]<=x[j]겠죠. (a)

x[1]에 설치했다고 가정해 볼까요?

x[1] + L이상인 최초의 지점이 q라고 해 봅시다. 즉, x[1] + L <= x[q]이고, x[q-1] < x[1]+L인 셈이죠. (b)

이 경우, q의 위치부터 설치할 수 있습니다.

문제는 x[2]에 설치한 경우인데요.

x[1] + L <= x[2] + L입니다. (c)

그렇다면, x[2] + L이상인 최초의 지점이 t일 때, q<=t일 수 밖에 없습니다. 왜냐면, x[1] <= x[2]이기 때문입니다.

이 부분은 (a), (b), (c)를 이용해서 증명해 보세요.

굵은색으로 칠한 명제를 일반화 시킨다면.

최대한 왼쪽에 설치할수록, 그 다음 공유기는 왼쪽에 설치할 수 있고. 더 많이 설치할 수 있게 됩니다.
